<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Procesador de Video</title>
    <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
    <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">
    
    <style>
        /* Estilos anteriores sin cambios */
    </style>
</head>
<body>
    <h1>Procesador de Video</h1>
    
    <div id="compatibility-check" class="error-message" style="display:none;"></div>
    
    <div id="drop-zone">
        Arrastra y suelta archivos MP4 aquí
        <input type="file" id="file-input" accept="video/mp4" multiple style="display:none;">
    </div>

    <!-- Resto del HTML anterior sin cambios -->

    <!-- Cargar FFmpeg de manera más explícita -->
    <script>
        // Configuración global para depuración
        window.DEBUG_FFMPEG = true;
    </script>
    <script src="/ffmpeg/ffmpeg.min.js"></script>
    <script src="/ffmpeg/ffmpeg-core.js"></script>
    <script src="/ffmpeg/ffmpeg-core.worker.js"></script>
    <script>
        // Función de diagnóstico de compatibilidad
        function checkFFmpegCompatibility() {
            const checks = [
                {
                    name: 'SharedArrayBuffer',
                    check: () => typeof SharedArrayBuffer !== 'undefined',
                    message: 'SharedArrayBuffer no disponible'
                },
                {
                    name: 'WebAssembly',
                    check: () => !!window.WebAssembly,
                    message: 'WebAssembly no soportado'
                },
                {
                    name: 'Cross-Origin Isolation',
                    check: () => window.crossOriginIsolated,
                    message: 'Cross-Origin Isolation no habilitado'
                }
            ];

            const failedChecks = checks.filter(check => !check.check());

            if (failedChecks.length > 0) {
                console.error('Incompatibilidades detectadas:', failedChecks);
                return false;
            }
            return true;
        }

        // Función de carga segura de FFmpeg
        async function loadFFmpegSafely() {
            // Verificar compatibilidad
            if (!checkFFmpegCompatibility()) {
                throw new Error('Entorno no compatible con FFmpeg WASM');
            }

            // Intentar múltiples formas de importación
            if (typeof createFFmpeg === 'undefined') {
                console.warn('createFFmpeg no definido globalmente, intentando alternativas');
                
                // Verificar si está en window.FFmpeg
                if (window.FFmpeg && window.FFmpeg.createFFmpeg) {
                    return window.FFmpeg.createFFmpeg;
                }

                // Intentar cargar dinámicamente
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = '/ffmpeg/ffmpeg.min.js';
                    script.onload = () => {
                        if (typeof createFFmpeg !== 'undefined') {
                            resolve(createFFmpeg);
                        } else {
                            reject(new Error('No se pudo cargar FFmpeg'));
                        }
                    };
                    script.onerror = () => reject(new Error('Error cargando script de FFmpeg'));
                    document.head.appendChild(script);
                });
            }

            return createFFmpeg;
        }

        // Modificación del procesamiento de video
        async function processVideoWithFFmpeg(file, ffmpeg, options) {
            const { bitrate, fps, keepAudio } = options;

            try {
                // Escribir archivo de entrada
                ffmpeg.FS('writeFile', 'input.mp4', await fetchFile(file));

                // Construir comando FFmpeg
                const ffmpegCommand = [
                    '-i', 'input.mp4',
                    '-c:v', 'libx264',
                    '-profile:v', 'high',
                    '-level', '4.0',
                    '-b:v', `${bitrate}k`,
                    '-r', fps,
                    keepAudio ? '' : '-an',
                    'output.mp4'
                ].filter(Boolean);

                // Procesar video
                await ffmpeg.run(...ffmpegCommand);
                
                // Leer archivo de salida
                return ffmpeg.FS('readFile', 'output.mp4');
            } catch (error) {
                console.error('Error en procesamiento de video:', error);
                throw error;
            }
        }

        // Modificar el evento de procesamiento
        processBtn.addEventListener('click', async () => {
            if (currentFiles.length === 0) {
                statusDiv.textContent = 'Por favor, seleccione archivos primero';
                return;
            }

            try {
                // Cargar FFmpeg de manera segura
                const createFFmpegFunc = await loadFFmpegSafely();

                // Configurar FFmpeg
                const ffmpeg = createFFmpegFunc({ 
                    log: true,
                    corePath: '/ffmpeg/ffmpeg-core.js',
                    mainName: 'main',
                    workerPath: '/ffmpeg/ffmpeg-core.worker.js'
                });
                
                // Configurar logger
                ffmpeg.setLogger((log) => {
                    if (window.DEBUG_FFMPEG) {
                        console.log('FFmpeg Log:', log.message);
                    }
                    progressContainer.style.display = 'block';
                    progressDetails.innerHTML += `${log.message}<br>`;
                });

                statusDiv.textContent = 'Cargando FFmpeg...';
                await ffmpeg.load();

                // Procesar cada archivo
                const processedFiles = [];
                for (const file of currentFiles) {
                    const processedData = await processVideoWithFFmpeg(file, ffmpeg, {
                        bitrate: document.getElementById('bitrate').value,
                        fps: document.getElementById('fps').value,
                        keepAudio: document.getElementById('keep-audio').checked
                    });

                    const blob = new Blob([processedData.buffer], { type: 'video/mp4' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `processed_${file.name}`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);

                    processedFiles.push(processedData);
                }

                statusDiv.textContent = 'Procesamiento completado';
                currentFiles = []; // Limpiar lista de archivos
                dropZone.textContent = 'Arrastra y suelta archivos MP4 aquí';
                videoConfig.style.display = 'none';
                progressContainer.style.display = 'none';

            } catch (error) {
                console.error('Error de procesamiento:', error);
                statusDiv.textContent = `Error: ${error.message}`;
                
                // Mostrar detalles de depuración
                const debugInfo = `
Detalles de depuración:
- createFFmpeg: ${typeof createFFmpeg}
- FFmpeg global: ${window.FFmpeg}
- Scripts cargados: 
  * ffmpeg.min.js
  * ffmpeg-core.js
  * ffmpeg-core.worker.js
`;
                statusDiv.innerHTML += `<pre>${debugInfo}</pre>`;
            }
        });
    </script>
</body>
</html>
