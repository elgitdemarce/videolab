<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SIA LAB | Video Process</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  label { display: block; margin-top: 10px; }
  input[type="number"] { width: 80px; }
  #progress { width: 100%; height: 20px; margin-top: 10px; }
  #progressDetails a { display: block; margin-top: 5px; }
  #status { color: #3f8ef5; margin-top: 10px; font-weight: bold; }

  /* Zona Drag and Drop */
  #dropZone {
    margin-top: 15px;
    padding: 60px;
    border: 3px dashed #69a2d1;
    border-radius: 8px;
    text-align: center;
    color: #5874f5;
    transition: background-color 0.3s, border-color 0.3s;
    user-select: none;
  }
  #dropZone.dragover {
    background-color: #f0f8ff;
    border-color: #1e90ff;
    color: #1e90ff;
  }
</style>
</head>
<body>

<h2>SIA LAB | Video Process</h2>

<label>Selecciona archivos de video:
  <input type="file" id="fileInput" multiple accept="video/*" />
</label>

<!-- Zona Drag and Drop -->
<div id="dropZone">Ó directamente arrastra y suelta tus archivos de video aquí para agregarlos</div>

<label>Bitrate (kbps):
  <input type="number" id="bitrate" value="2000" min="100" max="10000" />
</label>

<label>FPS:
  <input type="number" id="fps" value="30" min="1" max="60" />
</label>

<label>Buffer size (kb):
  <input type="number" id="buffsize" value="8192" min="1024" max="65536" />
</label>

<label>
  <input type="checkbox" id="keepAudio" checked /> Mantener audio
</label>

<label>Número de partes a dividir horizontalmente:
  <input type="number" id="parts" value="1" min="1" max="10" />
</label>

<button id="start">Procesar Videos</button>

<progress id="progress" value="0" max="100"></progress>

<div id="status"></div>

<div id="progressDetails"></div>

<script src="https://unpkg.com/@ffmpeg/ffmpeg@0.10.1/dist/ffmpeg.min.js"></script>
<script>
  const { createFFmpeg, fetchFile } = FFmpeg;
  const startBtn = document.getElementById('start');
  const bitrateInput = document.getElementById('bitrate');
  const fpsInput = document.getElementById('fps');
  const buffsizeInput = document.getElementById('buffsize');
  const keepAudioCheckbox = document.getElementById('keepAudio');
  const partsInput = document.getElementById('parts');
  const progressBar = document.getElementById('progress');
  const statusDiv = document.getElementById('status');
  const progressDetails = document.getElementById('progressDetails');
  const fileInput = document.getElementById('fileInput');
  const dropZone = document.getElementById('dropZone');

  let currentFiles = [];
  let isProcessing = false;

  // Variable para almacenar los logs de consola
  let ffmpegLogs = '';

  // Actualizar currentFiles al seleccionar archivos con el input
  fileInput.addEventListener('change', () => {
    currentFiles = Array.from(fileInput.files);
  });

  // Función para añadir archivos desde drop (sin duplicados)
  function addFiles(newFiles) {
    for (const file of newFiles) {
      if (!currentFiles.some(f => f.name === file.name && f.size === file.size && f.lastModified === file.lastModified)) {
        currentFiles.push(file);
      }
    }
  }

  // Drag & Drop listeners
  dropZone.addEventListener('dragenter', (e) => {
    e.preventDefault();
    e.stopPropagation();
    dropZone.classList.add('dragover');
  });

  dropZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    e.stopPropagation();
    dropZone.classList.add('dragover');
  });

  dropZone.addEventListener('dragleave', (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (!dropZone.contains(e.relatedTarget)) {
      dropZone.classList.remove('dragover');
    }
  });

  dropZone.addEventListener('drop', (e) => {
    e.preventDefault();
    e.stopPropagation();
    dropZone.classList.remove('dragover');

    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      const droppedFiles = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('video/'));
      if (droppedFiles.length === 0) {
        alert('Solo se permiten archivos de video.');
        return;
      }
      addFiles(droppedFiles);
      statusDiv.textContent = `${currentFiles.length} archivo(s) listo(s) para procesar: ${currentFiles.map(f => f.name).join(', ')}`;
    }
  });

  const ffmpeg = createFFmpeg({ log: true });

  async function getVideoDimensions(file) {
    return new Promise((resolve) => {
      const video = document.createElement('video');
      video.preload = 'metadata';
      video.src = URL.createObjectURL(file);
      video.onloadedmetadata = () => {
        resolve({ width: video.videoWidth, height: video.videoHeight });
        URL.revokeObjectURL(video.src);
      };
    });
  }

  function setProgress(value) {
    progressBar.value = value;
  }

  startBtn.onclick = () => processFiles();

  async function processFiles() {
    if (isProcessing) {
      alert('Ya hay un proceso en ejecución. Espera a que termine.');
      return;
    }
    if (currentFiles.length === 0) {
      alert('No hay archivos para procesar.');
      return;
    }

    isProcessing = true;
    startBtn.disabled = true;
    setProgress(0);
    progressDetails.innerHTML = '';
    statusDiv.textContent = 'Cargando FFmpeg...';

    ffmpegLogs = ''; // Reiniciar logs

    try {
      if (!ffmpeg.isLoaded()) {
        await ffmpeg.load();
      }

      // Capturar logs de ffmpeg y guardarlos en ffmpegLogs
      ffmpeg.setLogger(({ type, message }) => {
        ffmpegLogs += `[${type}] ${message}\n`;
      });

      const bitrate = parseInt(bitrateInput.value, 10) || 2000;
      const fps = parseInt(fpsInput.value, 10) || 30;
      const buffsize = parseInt(buffsizeInput.value, 10) || 8192;
      const keepAudio = keepAudioCheckbox.checked;
      const parts = Math.max(1, parseInt(partsInput.value, 10) || 1);

      let totalTasks = currentFiles.length * parts;
      let completedTasks = 0;

      for (let fileIndex = 0; fileIndex < currentFiles.length; fileIndex++) {
        const file = currentFiles[fileIndex];

        const { width, height } = await getVideoDimensions(file);
        const cropWidth = Math.floor(width / parts);
        const cropHeight = height;

        try { ffmpeg.FS('unlink', 'input.mp4'); } catch {}

        ffmpeg.FS('writeFile', 'input.mp4', await fetchFile(file));

        for (let i = 0; i < parts; i++) {
          const offsetX = i * cropWidth;
          const outputName = `output_part${i + 1}.mp4`;

          const cropFilter = `crop=${cropWidth}:${cropHeight}:${offsetX}:0`;

          let args = [
            '-i', 'input.mp4',
            '-filter:v', cropFilter,
            '-c:v', 'libx264',
            '-profile:v', 'high',
            '-level', '4.0',
            '-b:v', `${bitrate}k`,
            '-r', fps.toString(),
            '-bufsize', `${buffsize}k`
          ];

          if (!keepAudio) {
            args.push('-an');
          } else {
            args.push('-c:a', 'copy');
          }

          args.push(outputName);

          ffmpeg.setProgress(({ ratio }) => {
            const globalProgress = ((completedTasks + ratio) / totalTasks) * 100;
            setProgress(globalProgress);
            statusDiv.textContent = `Procesando ${file.name}, parte ${i + 1} de ${parts} (${globalProgress.toFixed(1)}%)`;
          });

          await ffmpeg.run(...args);

          const data = ffmpeg.FS('readFile', outputName);
          const videoBlob = new Blob([data.buffer], { type: 'video/mp4' });
          const url = URL.createObjectURL(videoBlob);

          const a = document.createElement('a');
          a.href = url;
          a.download = `procesado_parte${i + 1}_${file.name}`;
          a.textContent = `Descargar parte ${i + 1} de ${file.name}`;
          progressDetails.appendChild(a);

          try { ffmpeg.FS('unlink', outputName); } catch {}

          completedTasks++;
        }

        try { ffmpeg.FS('unlink', 'input.mp4'); } catch {}
      }

      setProgress(100);
      statusDiv.textContent = 'Procesamiento completado.';

      // Crear enlace para descargar logs en txt
      const logBlob = new Blob([ffmpegLogs], { type: 'text/plain' });
      const logUrl = URL.createObjectURL(logBlob);
      const logLink = document.createElement('a');
      logLink.href = logUrl;
      logLink.download = 'ffmpeg_logs.txt';
      logLink.textContent = 'Descargar registro completo de consola (logs)';
      logLink.style.display = 'block';
      logLink.style.marginTop = '15px';
      progressDetails.appendChild(logLink);

    } catch (err) {
      console.error(err);
      statusDiv.textContent = 'Error durante el procesamiento: ' + err.message;
    } finally {
      startBtn.disabled = false;
      ffmpeg.setProgress(() => {});
      isProcessing = false;
    }
  }
</script>

</body>
</html>
